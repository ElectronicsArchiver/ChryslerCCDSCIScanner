/*
 * ChryslerCCDSCIScanner_extEEPROM_write (https://github.com/laszlodaniel/ChryslerCCDSCIScanner)
 * Copyright (C) 2018, László Dániel
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

// Board setting: Arduino/Genuino Mega or Mega 2560
// Processor setting: ATmega2560 (Mega 2560)

#include <extEEPROM.h> // https://github.com/JChristensen/extEEPROM
#include <Wire.h>

#ifndef F_CPU
#define F_CPU 16000000UL // 16 MHz system clock
#endif

// Construct an object called "eep" for the external 24LC32A EEPROM chip
extEEPROM eep(kbits_32, 1, 32, 0x50); // device size: 32 kilobits = 4 kilobytes, number of devices: 1, page size: 32 bytes (from datasheet), device address: 0x50 by default

// First 256 bytes of the total 4096 bytes are reserved for identification purposes
// Memory map:
// $00-$01: hardware version (times 100, example: V1.40 = 140(DEC) = $008C)
// $02-$09: hardware date (assembly date in 64-bit UNIX time, example: 2018.12.03 10:36:00 = $000000005C05073D)
// $0A-$FE: reserved for future data
uint8_t eeprom_data_01[256] =
{
    0x00, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x05, 
    0x07, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // last entry is the checksum byte which is calculated automatically before eeprom write
};

void setup()
{
    Serial.begin(250000);
    
    uint8_t eep_status = eep.begin(extEEPROM::twiClock400kHz);   //go fast!
    
    if (eep_status)
    {
        Serial.print(F("extEEPROM.begin() failed, status = "));
        Serial.println(eep_status);
        while(true); // don't go further
    }

    uint8_t checksum = 0; // begin checksum calculation in this variable
    for (uint8_t i = 0; i < 255; i++) // add all 255 bytes together and skip last byte (where the result of this calculation goes) by setting the second parameter to 255 instead of 256
    {
        checksum += eeprom_data_01[i]; // checksum variable will roll over several times but it's okay, this is its purpose
    }
    eeprom_data_01[255] = checksum & 0xFF; // place checksum byte at the last position of the array
    
    // Disable hardware write protection (EEPROM chip has a pullup resistor at its WP-pin!)
    DDRE |= (1 << PE2); // set PE2 pin as output
    PORTE &= ~(1 << PE2); // pull PE2 pin low to disable write protection
    
    uint8_t eep_result = eep.write(0, eeprom_data_01, 256); // write bytes to external eeprom
    
    PORTE |= (1 << PE2); // pull PE2 pin high to enable write protection

    if (eep_result)
    {
        Serial.print(F("extEEPROM.write() failed, result = "));
        Serial.println(eep_result); // print error code to serial port
    }
    else
    {
        Serial.println(F("Success!"));
    }

    // TODO: read eeprom data back and compare with original data to ensure everything is OK.
}

void loop()
{
    // Do nothing else
}
